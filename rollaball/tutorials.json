{
  "tutorials": [
	{
	  "title": "RollBall",
	   "steps": [
		{
		  "step_number": 0,
		  "title": "Step 1: Project & Main Scene Setup",
		  "description": "1. Create a new Godot Project named 'RollBall' using the 'Forward+' renderer.\n2. Create a new 3D Scene, rename the root node to 'Main', and save it as 'main.tscn'. This will be our main stage where we will assemble all the pieces of our game.",
		  "demo_scene": "res://Tutorials/RollBall/Step1/demo.tscn"
		},
		{
		  "step_number": 1,
		  "title": "Step 2: Blueprint - The Arena",
		  "description": "First, let's build the arena as a separate, reusable scene.\n1. Create a NEW 3D Scene. Name the root 'Node3D' node 'Arena'.\n2. Inside, create a 'StaticBody3D' for the floor (with its Mesh and CollisionShape) and four more for the walls. Save this self-contained scene as 'arena.tscn'.\n\nNow, let's add our arena to the main stage and light it.\n1. Open your 'main.tscn' scene.\n2. Instance your 'arena.tscn' scene as a child of the 'Main' node.\n3. To make the scene visible, add a 'DirectionalLight3D' node. Rotate it to cast interesting shadows.\n4. Add a 'WorldEnvironment' node and create a new 'Environment' resource for it. Inside the resource, set the Background mode to 'Sky' to get a nice blue sky.\n5. Run the scene (F5). You should now see your empty, well-lit arena.",
		  "demo_scene": "res://Tutorials/RollBall/Step2/demo_arena.tscn"
		},
		{
		  "step_number": 3,
		  "title": "Step 3: Blueprint & Scripting - The Player",
		  "description": "Now for the player. We'll create its blueprint and its logic in one go.\n1. Create a NEW 3D Scene with a 'CharacterBody3D' as the root, named 'Player'. Add its Mesh and Collision shape.\n2. Attach a script ('player.gd') to it. Write the code for smooth, 'lerp'-based movement.\n3. Add the 'Player' node to the 'player' group via the Node tab.\n4. Save this scene as 'player.tscn'.",
		  "code_snippet": "extends CharacterBody3D\n\n@export var speed = 14.0\n@export var acceleration = 10.0\n# ... (lerp-based movement logic) ...",
		  "demo_scene": "res://Tutorials/RollBall/Step4/demo_player.tscn",
		  "solution_script": "res://Tutorials/RollBall/Step4/player.gd"
		},
		{
		  "step_number": 4,
		  "title": "Step 4: Assembling the Player & Camera",
		  "description": "Let's add the player to the stage and make the camera follow it.\n1. Open 'main.tscn' and instance your 'player.tscn' scene. Position it above the floor.\n2. Add a 'Camera3D' node to 'Main'. Position it for a good view.\n3. Attach a 'camera_follow.gd' script to the Camera. This script needs an '@export var target'.\n4. Drag the 'Player' instance from your scene tree into the camera's 'Target' slot in the Inspector.\n5. Run the game. You now have a playable character in your arena!",
		  "demo_scene": "res://Tutorials/RollBall/Step5/demo_main_playable.tscn"
		},
		{
		  "step_number": 5,
		  "title": "Step 5: Blueprint - Collectibles & Obstacles",
		  "description": "To prepare for procedural generation, we need blueprints for the items we want to spawn.\n1. **Collectible:** Create a new scene 'collectible.tscn' ('Area3D' root) with a mesh, collision shape, and a script for rotation and signal emission ('collected').\n2. **Obstacle:** Create another new scene 'obstacle.tscn' ('StaticBody3D' root) with a mesh and collision shape.",
		  "demo_scene": "res://Tutorials/RollBall/Step6/demo_blueprints.tscn"
		},
		{
		  "step_number": 6,
		  "title": "Step 6: Final Assembly - UI, Logic & Generation",
		  "description": "This is the final step where we add all game rules.\n1. **Add UI:** In 'main.tscn', add a 'CanvasLayer' with a 'ScoreLabel' and a hidden 'WinLabel'.\n2. **Add Game Logic:** Attach a 'main.gd' script to the 'Main' node.\n3. **Implement Generation:** In this script, write the `generate_layout` function to procedurally spawn instances of your collectible and obstacle blueprints.\n4. **Implement Rules:** In the same script, add the score and victory logic. Connect the 'collected' signal from each spawned collectible to your score function via code `new_collectible.collected.connect(...)`.\n5. Link the blueprint scenes in the Inspector. Run the game. It is now complete!",
		  "code_snippet": "func _ready():\n\t# ...\n\tgenerate_layout()\n\nfunc generate_layout():\n\t# ... (Spawns collectibles & obstacles) ...\n\tnew_collectible.collected.connect(_on_collectible_collected)\n\nfunc _on_collectible_collected():\n\t# ... (Handles score and checks for win condition) ...",
		  "demo_scene": "res://Tutorials/RollBall/Step7/demo_final_game.tscn",
		  "solution_script": "res://Tutorials/RollBall/Step7/main.gd"
		}
	  ]
	},
	  {
		"title": "State Machine",
		"steps": [
		  {
			"step_number": 1,
			"title": "Step 1: Création du Monde",
			"description": "Créer une scène 2D. Ajouter un Sol et deux Murs (StaticBody2D) avec leurs formes de collision. Créer un Ennemi (CharacterBody2D) avec son visuel et sa collision, puis le placer correctement entre les deux murs sans chevauchement.",
			"demo_scene": "res://Tutorials/AI_FSM/Step1/demo.tscn",
			"solution_script": "res://Tutorials/AI_FSM/Step1/solution.gd"
		  },
		  {
			"step_number": 2,
			"title": "Step 2: La Machine à États (FSM)",
			"description": "Créer un script 'state_machine.gd' avec la classe de base 'State' et le mot-clé 'class_name'. Dans le script 'ennemi.gd', préparer la variable 'current_state' pour accueillir le futur comportement de l'ennemi.",
			"demo_scene": "res://Tutorials/AI_FSM/Step2/demo.tscn",
			"solution_script": "res://Tutorials/AI_FSM/Step2/solution.gd"
		  },
		  {
			"step_number": 3,
			"title": "Step 3: L'État de Patrouille",
			"description": "Ajouter la classe interne 'PatrolState' au script de l'ennemi. Implémenter la logique de déplacement horizontal qui s'inverse en touchant un mur via is_on_wall(). Initialiser cet état au démarrage.",
			"demo_scene": "res://Tutorials/AI_FSM/Step3/demo.tscn",
			"solution_script": "res://Tutorials/AI_FSM/Step3/solution.gd"
		  },
		  {
			"step_number": 4,
			"title": "Step 4: Détection et Couches Physiques",
			"description": "Ajouter un Joueur (CharacterBody2D). Ajouter une Area2D à l'Ennemi. Connecter les signaux 'body_entered' et 'body_exited'.",
			"demo_scene": "res://Tutorials/AI_FSM/Step4/demo.tscn",
			"solution_script": "res://Tutorials/AI_FSM/Step4/solution.gd"
		  },
		  {
			"step_number": 5,
			"title": "Step 5: L'État de Poursuite",
			"description": "Ajouter la classe interne 'ChaseState'. Mettre à jour les signaux de détection pour changer l'état de l'ennemi entre 'PatrolState' et 'ChaseState', lui permettant de poursuivre le joueur horizontalement quand il est détecté.",
			"demo_scene": "res://Tutorials/AI_FSM/Step5/demo.tscn",
			"solution_script": "res://Tutorials/AI_FSM/Step5/solution.gd"
		  }
		]
	  }
	]
}
